"""
Autogenerated input for adding instance of Transcription
"""
input AddTranscriptionInput {
  """
  id
  """
  id: ID
  text: String
  confidence: Float
}

enum AggregateOp {
  MIN
  MAX
  SUM
  COUNT
}

input AudioAsInput {
  id: ID!
  file: FileAsInput
  duration: TimeDurationAsInput
  encoding: AudioEncodingAsInput
  sampleRate: RateAsInput
  format: AudioFormatAsInput
}

input AudioEncodingAsInput {
  id: ID!
  encoding: EncodingAsInput
  isLossless: Boolean
}

input AudioFormatAsInput {
  id: ID!
  format: FormatAsInput
}

input CountryAsInput {
  id: ID!
  name: String
  localizedName: LocalizedTextAsInput
}

scalar Date

scalar DateTime

input EncodingAsInput {
  id: ID!
  name: String
}

input FieldFilterInput {
  """
  one of the following is required
  """
  fieldId: ID
  fieldName: String
  op: String!
  value: FieldValueInput!
}

input FieldProjectionInput {
  """
  one of the following is required - except in the case of count queries
  """
  fieldId: ID
  fieldName: String

  """
  optional if omitted outer query is used
  """
  alias: String
  op: AggregateOp
}

type FieldValue {
  """
  Types
  """
  ID: ID
  STRING: String
  INT: Int
  FLOAT: Float
  BOOLEAN: Boolean
  DATE: Date
  TIME: Time
  DATETIME: DateTime
  JSON: JSON
  KIND: ID

  """
  List forms
  """
  l_ID: [ID]
  l_STRING: [String]
  l_INT: [Int]
  l_FLOAT: [Float]
  l_BOOLEAN: [Boolean]
  l_DATE: [Date]
  l_TIME: [Time]
  l_DATETIME: [DateTime]
  l_JSON: [JSON]
  l_KIND: [ID]
}

input FieldValueInput {
  """
  Types
  """
  ID: ID
  STRING: String
  INT: Int
  FLOAT: Float
  BOOLEAN: Boolean
  DATE: Date
  TIME: Time
  DATETIME: DateTime
  JSON: JSON
  KIND: ID

  """
  List forms
  """
  l_ID: [ID]
  l_STRING: [String]
  l_INT: [Int]
  l_FLOAT: [Float]
  l_BOOLEAN: [Boolean]
  l_DATE: [Date]
  l_TIME: [Time]
  l_DATETIME: [DateTime]
  l_JSON: [JSON]
  l_KIND: [ID]
}

input FileAsInput {
  id: ID!
  policies: [RBACPolicyAsInput]
  size: SizeAsInput
  format: FormatAsInput
  encoding: EncodingAsInput
  name: String
}

input FormatAsInput {
  id: ID!
  name: String
}

type Info {
  id: ID!
  name: String!
  description: String
}

type InstanceSet {
  kindId: ID!

  """
  Continuation token
  """
  token: String
  fieldIds: [ID]

  """
  rowKeys: [Int]
  """
  records: [[FieldValue]]
}

scalar JSON

input KindQueryInput {
  """
  projected kind (one of the following is required)
  """
  kindId: ID
  kindName: String
  serviceId: ID

  """
  optional alias for projection binding
  """
  alias: String

  """
  projected fields
  """
  projection: [FieldProjectionInput]

  """
  distinct Projected result
  """
  distinct: Boolean

  """
  filters (where)
  """
  fieldFilters: [FieldFilterInput]

  """
  conjunction (where)
  """
  and: [KindQueryInput]

  """
  disjunction (where)
  """
  or: [KindQueryInput]

  """
  join (if conjunction or disjunction)
  """
  fromFieldId: ID
  fromFieldName: String
  toFieldId: ID
  toFieldName: String
  take: Int
  token: String
}

input LanguageAsInput {
  id: ID!
  localizedName: LocalizedTextAsInput
  name: String
}

input LanguageTagAsInput {
  id: ID!
  languageCode: LanguageAsInput
  country: CountryAsInput
}

input LocalizedTextAsInput {
  id: ID!
  languageTag: LanguageTagAsInput
  text: String!
}

type Mutation {
  """
  Autogenerated mutation for adding single instance of Transcription
  """
  addTranscription(input: AddTranscriptionInput!): ID

  """
  Autogenerated mutation for adding multiple instances of Transcription
  """
  addTranscriptions(input: [AddTranscriptionInput]!): [ID]

  """
  Autogenerated mutation for updating single instance of Transcription
  """
  updateTranscription(input: UpdateTranscriptionInput!): ID

  """
  Autogenerated mutation for updating multiple instance of Transcription
  """
  updateTranscriptions(input: [UpdateTranscriptionInput]!): [ID]

  """
  Autogenerated mutation for deleting single instance of Transcription
  """
  deleteTranscription(id: ID!): Transcription

  """
  Autogenerated mutation for deleting multiple instance of Transcription
  """
  deleteTranscriptions(ids: [ID!]): [Transcription]
}

type Query {
  getTranscriptionText(transcription: TranscriptionAsInput!): String!
  getTranscriptionConfidence(transcription: TranscriptionAsInput!): Float!
  recognize(
    audio: AudioAsInput!
    sourceLanguageTag: LanguageTagAsInput
  ): TranscriptionOutput!
  makeTranscription(
    id: ID
    text: String
    confidence: Float
  ): TranscriptionOutput!
  CKGErrors: [String]

  """
  All instances of Transcription kind
  """
  allTranscriptions(
    """
    Number of results to return
    """
    take: Int = 1000

    """
    Number of results to skip from the query result. Applied before take
    """
    offset: Int = 0
  ): [Transcription]

  """
  Get single instance of Transcription kind by ID
  """
  transcription(id: ID!): Transcription

  """
  Get list of instance of Transcription kind by IDs
  """
  transcriptions(ids: [ID]!): [Transcription]

  """
  Get instances of Transcription kind based on one or more field filters
  """
  transcriptionFilter(
    filters: [FieldFilterInput]!

    """
    Number of results to return
    """
    take: Int = 1000

    """
    Number of results to skip from the query result. Applied before take
    """
    offset: Int = 0
  ): [Transcription]

  """
  Mandatory service manifest.
  """
  info: Info!

  """
  Kind Query
  """
  query(input: KindQueryInput!): InstanceSet
  queryJSON(input: KindQueryInput!): String
}

input RateAsInput {
  id: ID!
  frequency: Float
  units: UnitOfMeasureAsInput
}

input RBACAuthorityAsInput {
  id: ID!
  description: String
}

input RBACPolicyAsInput {
  id: ID!
  rbacAuthority: RBACAuthorityAsInput!
  rbacRole: RBACRoleAsInput!
  rbacVerb: RBACVerbAsInput!
  effective: DateTime
  expires: DateTime
  objectId: ID!
}

input RBACRoleAsInput {
  id: ID!
  description: String
}

input RBACVerbAsInput {
  id: ID!
  description: String
}

input SizeAsInput {
  id: ID!
  units: UnitOfMeasureAsInput
  amount: Float
}

scalar Time

input TimeDurationAsInput {
  id: ID!
  value: Float
  units: String
}

type Transcription {
  """
  id
  """
  id: ID!
  text: String
  confidence: Float
}

input TranscriptionAsInput {
  id: ID!
  text: String
  confidence: Float
}

type TranscriptionOutput {
  id: ID!
  text: String
  confidence: Float
}

input UnitOfMeasureAsInput {
  id: ID!
  name: String
  displayAs: String
}

"""
Autogenerated input for modifying instance of Transcription
"""
input UpdateTranscriptionInput {
  """
  id
  """
  id: ID!
  text: String
  confidence: Float
}
